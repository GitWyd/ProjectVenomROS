#!/usr/bin/env python
import cv2
import sys, os
sys.path.append(os.path.join(os.environ['HOME']+'/darknet/python/'))
import darknet as dn
import rospy
from ai_bridge import ImageReader
from std_msgs.msg import Int32MultiArray

# Convert OpenCV image to Darknet format
def array_to_image(arr):
  arr = arr.transpose(2,0,1)
  c = arr.shape[0]
  h = arr.shape[1]
  w = arr.shape[2]
  arr = (arr/255.0).flatten()
  data = dn.c_array(dn.c_float, arr)
  im = dn.IMAGE(w,h,c,data)
  return im

def detect(net, meta, image, thresh=.5, hier_thresh=.5, nms=.45):
  boxes = dn.make_boxes(net)
  probs = dn.make_probs(net)
  num =   dn.num_boxes(net)
  dn.network_detect(net, image, thresh, hier_thresh, nms, boxes, probs)
  res = []
  for j in range(num):
    for i in range(meta.classes):
      if probs[j][i] > 0:
        res.append((meta.names[i], probs[j][i],\
	           (boxes[j].x, boxes[j].y, boxes[j].w, boxes[j].h)))
  res = sorted(res, key=lambda x: -x[1])
  dn.free_ptrs(dn.cast(probs, dn.POINTER(dn.c_void_p)), num)
  return res

if __name__ == '__main__':
  darknet_path = os.environ['HOME']+'/darknet/drone_data/'
  net = dn.load_net(darknet_path+'tiny-yolo-drone.cfg',\
                    darknet_path+'tiny-yolo-drone.backup', 0)
  meta = dn.load_meta(darknet_path+b'drone1.data')
  
  image_reader = ImageReader()
  pub = rospy.Publisher('/venom/bounding_box', Int32MultiArray, queue_size=10)
  
  while not rospy.is_shutdown():
    image = image_reader.get_rgb()
    im = array_to_image(image)
    r = detect(net, meta, im, thresh=0.2, hier_thresh=0.5, nms=0.45)
    avg, weight = [0]*4, 0.0
    for region in r:
      if float('inf') not in region[2]:
        for e in range(len(region[2])):
            avg[e] += region[2][e]*region[1]
        weight += region[1]
    if len(r) > 0:
      for e in range(len(avg)): avg[e] /= weight
  
    # Convert the bounding box to top-left/bottom-right indices
    out = Int32MultiArray()
    out.data = [int(avg[0]-avg[2]/2.0), int(avg[1]-avg[3]/2.0),\
                int(avg[0]+avg[2]/2.0), int(avg[1]+avg[3]/2.0)]
    # Publish to ROS topic
    pub.publish(out)
